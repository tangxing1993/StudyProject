软件设计模式
============
[![builder](https://img.shields.io/badge/build-pass-green)]
(https://github.com/tangxing1993/StudyProject)

- 对接口编程而不是对实现编程
- 优先使用对象组合而不是继承

[参考资料1](http://c.biancheng.net/view/1317.html)

[参考资料2](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

**__设计原则__**
---------------
* 开闭原则
	
	* 对扩展开放,对修改关闭
	
	* 抽象约束,封装变化
	
* 里氏替换原则
	
	* 任何基类出现的地方子类一定可以出现

* 依赖倒置原则
	
	* 针对接口编程，依赖于抽象而不依赖实体

* 接口隔离原则
	
	* 使用多个隔离接口降低耦合

* 迪米特法则【最少知道原则】
	
	* 一个实体尽量少于其他实体之间发生相互作用,使的系统模块独立

* 合成复用原则
	
	* 尽量使用合成聚合的方式，而不是使用继承

**__设计模式__**
-----------------

	设计模式分为创建型,结构型和行为型
	
* 创建型 【主要是用于对象的构建】
	
	* 单例模式
	
		- 生成唯一对象
	
	* 原型模式
	
		- 生成多个不同的对象实例 （采用克隆）
	
	* 工厂模式【抽象工厂模式】
		
		- 主要解决接口选择问题,有明确计划创建不同实例
	
	* 建造者模式
		
		- 主要解决复杂对象的构建


* 结构型 【主要关注类和对象的组合】

	* 代理模式
		
	 - 应用场景 
	
		对某些无法直接访问的对象进行代理
	
	 - 使用技巧
		
		接口动态代理和cglib无接口动态代理
	
	* 适配器模式
		
	  - 应用场景
	  
	  将一个类的接口转化成客户希望的另一个接口
	  
	  - 使用技巧
	  
	  定义一个适配器类(继承或聚合)，然后实现目标接口
	   	
	* 桥接模式
	
	  - 应用场景
	  
	  当某个实体拥有多个变化的属性时,避免造成继承出现 n*n个子类,采用桥接的方式进行设计实体。
	  
	  - 使用技巧
	
	  使用抽象层聚合变化属性,将多个变化的属性拆解为借口并实现多种变化
	 
	* 装饰模式
	 
	  - 应用场景
	  
	  在不改变现有对象结构的情况下动态的给该对象增加一些职责
		
	  - 使用技巧
	  
	  可以使用抽象的包装类来聚合被包装的组件，并实现组件的接口。(如果只是一个包装对象可以省去抽象的包装类直接实现)
	 
	* 外观模式
	
	  - 应用场景
	  
	  将多个复杂的子系统提供一个一致对外的接口  （迪米特法则的典型应用）
	  
	  - 使用技巧
	  
	  将多个子系统的组合到外观类的内部，对外提供访问接口
	
	* 享元模式
	
	  - 应用场景
	  
	  运用共享技术有效的支持大量细粒度对象的调用
	  
	  - 使用场景


* 行为型 【关注对象之间的通信】
	
	